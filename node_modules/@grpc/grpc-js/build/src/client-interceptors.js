"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = require("./metadata");
const call_stream_1 = require("./call-stream");
const constants_1 = require("./constants");
class InterceptorConfigurationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InterceptorConfigurationError';
        Error.captureStackTrace(this, InterceptorConfigurationError);
    }
}
exports.InterceptorConfigurationError = InterceptorConfigurationError;
class ListenerBuilder {
    constructor() {
        this.metadata = undefined;
        this.message = undefined;
        this.status = undefined;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
    }
    withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
    }
    build() {
        return {
            onReceiveMetadata: this.metadata,
            onReceiveMessage: this.message,
            onReceiveStatus: this.status
        };
    }
}
exports.ListenerBuilder = ListenerBuilder;
class RequesterBuilder {
    constructor() {
        this.start = undefined;
        this.message = undefined;
        this.halfClose = undefined;
        this.cancel = undefined;
    }
    withStart(start) {
        this.start = start;
        return this;
    }
    withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
    }
    withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
    }
    withCancel(cancel) {
        this.cancel = cancel;
        return this;
    }
    build() {
        return {
            start: this.start,
            sendMessage: this.message,
            halfClose: this.halfClose,
            cancel: this.cancel
        };
    }
}
exports.RequesterBuilder = RequesterBuilder;
const defaultListener = {
    onReceiveMetadata: (metadata, next) => {
        next(metadata);
    },
    onReceiveMessage: (message, next) => {
        next(message);
    },
    onReceiveStatus: (status, next) => {
        next(status);
    }
};
const defaultRequester = {
    start: (metadata, listener, next) => {
        next(metadata, listener);
    },
    sendMessage: (message, next) => {
        next(message);
    },
    halfClose: (next) => {
        next();
    },
    cancel: (next) => {
        next();
    }
};
class InterceptingCall {
    constructor(nextCall, requester) {
        this.nextCall = nextCall;
        if (requester) {
            // Undefined elements overwrite, unset ones do not
            this.requester = {
                start: requester.start || defaultRequester.start,
                sendMessage: requester.sendMessage || defaultRequester.sendMessage,
                halfClose: requester.halfClose || defaultRequester.halfClose,
                cancel: requester.cancel || defaultRequester.cancel
            };
        }
        else {
            this.requester = defaultRequester;
        }
    }
    cancelWithStatus(status, details) {
        this.requester.cancel(() => {
            this.nextCall.cancelWithStatus(status, details);
        });
    }
    getPeer() {
        return this.nextCall.getPeer();
    }
    start(metadata, interceptingListener) {
        this.requester.start(metadata, interceptingListener, (md, listener) => {
            let finalInterceptingListener;
            if (call_stream_1.isInterceptingListener(listener)) {
                finalInterceptingListener = listener;
            }
            else {
                const fullListener = {
                    onReceiveMetadata: listener.onReceiveMetadata || defaultListener.onReceiveMetadata,
                    onReceiveMessage: listener.onReceiveMessage || defaultListener.onReceiveMessage,
                    onReceiveStatus: listener.onReceiveStatus || defaultListener.onReceiveStatus
                };
                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, interceptingListener);
            }
            this.nextCall.start(md, finalInterceptingListener);
        });
    }
    write(writeObj, callback) {
        this.requester.sendMessage(writeObj.message, (message) => {
            this.nextCall.write({ message: message, flags: writeObj.flags }, callback);
        });
    }
    startRead() {
        this.nextCall.startRead();
    }
    halfClose() {
        this.requester.halfClose(() => {
            this.nextCall.halfClose();
        });
    }
    getDeadline() {
        return this.nextCall.getDeadline();
    }
    getCredentials() {
        return this.nextCall.getCredentials();
    }
    setCredentials(credentials) {
        this.nextCall.setCredentials(credentials);
    }
    getMethod() {
        return this.nextCall.getHost();
    }
    getHost() {
        return this.nextCall.getHost();
    }
}
exports.InterceptingCall = InterceptingCall;
function getCall(channel, path, options) {
    var deadline;
    var host;
    var parent;
    var propagate_flags;
    var credentials;
    if (options) {
        deadline = options.deadline;
        host = options.host;
        propagate_flags = options.propagate_flags;
        credentials = options.credentials;
    }
    if (deadline === undefined) {
        deadline = Infinity;
    }
    var call = channel.createCall(path, deadline, host, parent, propagate_flags);
    if (credentials) {
        call.setCredentials(credentials);
    }
    return call;
}
function getBottomInterceptingCall(channel, path, options, methodDefinition) {
    const call = getCall(channel, path, options);
    return new InterceptingCall(call, {
        start: (metadata, listener, next) => {
            let readError = null;
            next(metadata, {
                onReceiveMessage: (message, next) => {
                    let deserialized;
                    try {
                        deserialized = methodDefinition.responseDeserialize(message);
                        next(deserialized);
                    }
                    catch (e) {
                        readError = { code: constants_1.Status.INTERNAL, details: 'Failed to parse server response', metadata: new metadata_1.Metadata() };
                        call.cancelWithStatus(readError.code, readError.details);
                    }
                },
                onReceiveStatus: (status, next) => {
                    if (status.code === constants_1.Status.OK && readError !== null) {
                        next(readError);
                    }
                    else {
                        next(status);
                    }
                }
            });
        },
        sendMessage: (message, next) => {
            let serialized;
            try {
                serialized = methodDefinition.requestSerialize(message);
                next(serialized);
            }
            catch (e) {
                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');
            }
        }
    });
}
function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
            'to the client constructor. Only one of these is allowed.');
    }
    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
            'options. Only one of these is allowed.');
    }
    let interceptors = [];
    // Interceptors passed to the call override interceptors passed to the client constructor
    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);
        // Filter out falsy values when providers return nothing
    }
    else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);
        // Filter out falsy values when providers return nothing
    }
    const interceptorOptions = Object.assign({}, options, { method_definition: methodDefinition });
    /* For each interceptor in the list, the nextCall function passed to it is
     * based on the next interceptor in the list, using a nextCall function
     * constructed with the following interceptor in the list, and so on. The
     * initialValue, which is effectively at the end of the list, is a nextCall
     * function that invokes getBottomInterceptingCall, which handles
     * (de)serialization and also gets the underlying call from the channel */
    const getCall = interceptors.reduceRight((previousValue, currentValue) => {
        return currentOptions => currentValue(currentOptions, previousValue);
    }, (finalOptions) => getBottomInterceptingCall(channel, methodDefinition.path, finalOptions, methodDefinition));
    return getCall(interceptorOptions);
}
exports.getInterceptingCall = getInterceptingCall;
//# sourceMappingURL=client-interceptors.js.map